//
//  QueensApp.swift
//  Queens Cami's version
//
//  Created by Camila Monsalve on 30.10.2025.
//
// Queens â€“ SwiftUI iPhone App (Undo + AutoX + Generator + Live Highlights)
// Replace your entire QueensApp.swift with this file.
// iOS 16+

import SwiftUI
import Combine

@main
struct QueensApp: App {
    var body: some Scene {
        WindowGroup { QueensGameView() }
    }
}

// MARK: - Model

struct Puzzle: Identifiable, Hashable {
    let id = UUID()
    let size: Int
    let regionIds: [[Int]]
    let presetQueens: Set<BoardIndex>
}

struct BoardIndex: Hashable, Codable { let r: Int; let c: Int }

enum CellState: Equatable { case empty, queen, mark }

struct BoardState: Equatable {
    var size: Int
    var cells: [[CellState]]
    var presetQueens: Set<BoardIndex>

    static func empty(size: Int, preset: Set<BoardIndex>) -> BoardState {
        var cells = Array(repeating: Array(repeating: CellState.empty, count: size), count: size)
        for idx in preset { cells[idx.r][idx.c] = .queen }
        return BoardState(size: size, cells: cells, presetQueens: preset)
    }
}

// MARK: - Default puzzle (only used on first launch)
let samplePuzzles: [Puzzle] = {
    let N = 6
    let regions: [[Int]] = [
        [0,0,1,1,2,2],
        [0,3,3,1,2,2],
        [0,3,4,4,4,2],
        [5,3,4,1,4,2],
        [5,5,5,1,1,2],
        [5,3,3,3,1,2]
    ]
    return [Puzzle(size: N, regionIds: regions, presetQueens: [])]
}()

// MARK: - ViewModel

final class GameVM: ObservableObject {
    @Published var board: BoardState
    @Published var puzzle: Puzzle

    @Published var autoXEnabled: Bool = true
    private var autoMarks: Set<BoardIndex> = []
    @Published var history: [BoardState] = []

    init(puzzle: Puzzle) {
        self.puzzle = puzzle
        self.board = BoardState.empty(size: puzzle.size, preset: puzzle.presetQueens)
        rebuildAutoMarks()
    }

    var size: Int { board.size }

    func reset() {
        board = BoardState.empty(size: size, preset: puzzle.presetQueens)
        autoMarks.removeAll()
        history.removeAll()
        rebuildAutoMarks()
    }

    // Tap cycles: empty -> X -> queen -> empty
    func cycle(_ r: Int, _ c: Int) {
        let idx = BoardIndex(r: r, c: c)
        guard !board.presetQueens.contains(idx) else { return }
        history.append(board)
        switch board.cells[r][c] {
        case .empty: board.cells[r][c] = .mark
        case .mark:  board.cells[r][c] = .queen
        case .queen: board.cells[r][c] = .empty
        }
        rebuildAutoMarks()
        objectWillChange.send()
    }

    // Long-press toggles X directly
    func longPressMark(_ r: Int, _ c: Int) {
        let idx = BoardIndex(r: r, c: c)
        guard !board.presetQueens.contains(idx) else { return }
        history.append(board)
        board.cells[r][c] = (board.cells[r][c] == .mark) ? .empty : .mark
        rebuildAutoMarks()
        objectWillChange.send()
    }

    // MARK: - Validation

    struct Violation: Identifiable { let id = UUID(); let message: String }

    func checkViolations() -> [Violation] {
        var v: [Violation] = []
        let N = size
        for r in 0..<N { if (0..<N).filter({ board.cells[r][$0] == .queen }).count > 1 { v.append(.init(message: "Row \(r+1) has >1 queen")) } }
        for c in 0..<N { if (0..<N).filter({ board.cells[$0][c] == .queen }).count > 1 { v.append(.init(message: "Col \(c+1) has >1 queen")) } }
        var reg: [Int:Int] = [:]
        for r in 0..<N { for c in 0..<N where board.cells[r][c] == .queen { reg[puzzle.regionIds[r][c], default: 0] += 1 } }
        for (k,vn) in reg where vn > 1 { v.append(.init(message: "Region #\(k+1) has >1 queen")) }
        return v
    }

    func isSolved() -> Bool {
        let N = size
        for r in 0..<N { if (0..<N).filter({ board.cells[r][$0] == .queen }).count != 1 { return false } }
        for c in 0..<N { if (0..<N).filter({ board.cells[$0][c] == .queen }).count != 1 { return false } }
        var regionCount: [Int:Int] = [:]
        for r in 0..<N { for c in 0..<N { if board.cells[r][c] == .queen { regionCount[puzzle.regionIds[r][c], default: 0] += 1 } } }
        let regionTotal = puzzle.regionIds.flatMap{ $0 }.max() ?? -1
        for reg in 0...regionTotal { if regionCount[reg] != 1 { return false } }
        // No diagonal touching (adjacent diagonals only)
        let dirs = [(-1,-1),(-1,1),(1,-1),(1,1)]
        for r in 0..<N { for c in 0..<N where board.cells[r][c] == .queen {
            for (dr,dc) in dirs {
                let nr = r + dr, nc = c + dc
                if (0..<N).contains(nr) && (0..<N).contains(nc) && board.cells[nr][nc] == .queen { return false }
            }
        }}
        return true
    }

    func isQueenViolating(_ r: Int, _ c: Int) -> Bool {
        violatingQueenIndices().contains(BoardIndex(r: r, c: c))
    }

    private func violatingQueenIndices() -> Set<BoardIndex> {
        var bad: Set<BoardIndex> = []
        let N = size
        var queens: [BoardIndex] = []
        for r in 0..<N { for c in 0..<N { if board.cells[r][c] == .queen { queens.append(BoardIndex(r: r, c: c)) } } }
        for r in 0..<N {
            let q = queens.filter{ $0.r == r }
            if q.count > 1 { bad.formUnion(q) }
        }
        for c in 0..<N {
            let q = queens.filter{ $0.c == c }
            if q.count > 1 { bad.formUnion(q) }
        }
        var regMap: [Int:[BoardIndex]] = [:]
        for q in queens { regMap[puzzle.regionIds[q.r][q.c], default: []].append(q) }
        for (_,group) in regMap where group.count > 1 { bad.formUnion(group) }
        // Adjacent diagonal touching
        for i in 0..<queens.count {
            for j in i+1..<queens.count {
                let a = queens[i], b = queens[j]
                if abs(a.r - b.r) == 1 && abs(a.c - b.c) == 1 { bad.insert(a); bad.insert(b) }
            }
        }
        return bad
    }

    // MARK: - Auto-X

    func rebuildAutoMarks() {
        let N = size
        for idx in autoMarks { if board.cells[idx.r][idx.c] == .mark { board.cells[idx.r][idx.c] = .empty } }
        autoMarks.removeAll()
        guard autoXEnabled else { return }
        func markIfEmpty(_ r: Int, _ c: Int) {
            if board.cells[r][c] == .empty { board.cells[r][c] = .mark; autoMarks.insert(BoardIndex(r: r, c: c)) }
        }
        for r in 0..<N { for c in 0..<N where board.cells[r][c] == .queen {
            for cc in 0..<N where cc != c { markIfEmpty(r, cc) }
            for rr in 0..<N where rr != r { markIfEmpty(rr, c) }
            let reg = puzzle.regionIds[r][c]
            for rr in 0..<N { for cc in 0..<N where !(rr==r && cc==c) && puzzle.regionIds[rr][cc]==reg { markIfEmpty(rr, cc) } }
        }}
    }

    func undo() {
        guard let last = history.popLast() else { return }
        board = last
        rebuildAutoMarks()
        objectWillChange.send()
    }
}

// MARK: - Generator / Solver

extension GameVM {
    // Create a random partition into N regions (each region has N cells)
    static func makeRegions(size N: Int) -> [[Int]] {
        // Connected region generator: N regions, each exactly N cells, 4-neighbor connected.
        // If we get stuck, we restart up to a few tries.
        func attempt() -> [[Int]]? {
            var grid = Array(repeating: Array(repeating: -1, count: N), count: N)
            // Pick N distinct random seeds
            var all = Array(0..<(N*N)); all.shuffle()
            let seeds = Array(all.prefix(N))
            var frontiers: [[(Int,Int)]] = Array(repeating: [], count: N)
            for (rid, cell) in seeds.enumerated() {
                let r = cell / N, c = cell % N
                grid[r][c] = rid
                // initialize frontier with its 4-neighbors
                let nbrs = [(r-1,c),(r+1,c),(r,c-1),(r,c+1)].filter{ (rr,cc) in (0..<N).contains(rr) && (0..<N).contains(cc) && grid[rr][cc] == -1 }
                frontiers[rid].append(contentsOf: nbrs)
            }
            var sizes = Array(repeating: 1, count: N)
            // Grow each region until size N
            while true {
                if sizes.allSatisfy({ $0 == N }) { break }
                // Choose a region that still needs cells and has frontier
                let candidates = (0..<N).filter{ sizes[$0] < N && !frontiers[$0].isEmpty }
                if candidates.isEmpty { return nil } // stuck
                let rid = candidates.randomElement()!
                // pick a frontier cell
                var f = frontiers[rid]
                let idx = Int.random(in: 0..<f.count)
                let (r,c) = f[idx]
                // if already taken by someone else, drop and continue
                if grid[r][c] != -1 {
                    frontiers[rid].remove(at: idx)
                    continue
                }
                // claim it
                grid[r][c] = rid
                sizes[rid] += 1
                // add its free neighbors to this region's frontier
                for (rr,cc) in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)] {
                    if (0..<N).contains(rr) && (0..<N).contains(cc) && grid[rr][cc] == -1 {
                        frontiers[rid].append((rr,cc))
                    }
                }
                // remove duplicates to keep frontier small
                var seen = Set<Int>()
                frontiers[rid] = frontiers[rid].filter{ (rr,cc) in
                    let key = rr*N+cc
                    if seen.contains(key) { return false }
                    seen.insert(key); return true
                }
            }
            return grid
        }
        for _ in 0..<50 { if let g = attempt() { return g } }
        // Fallback to simple rows if generation fails
        return (0..<N).map { r in Array(repeating: r, count: N) }
    }

    // Backtracking solver to find one valid queen placement
    static func solve(size N: Int, regions: [[Int]]) -> [BoardIndex]? {
        var colUsed = Array(repeating: false, count: N)
        var regUsed = Array(repeating: false, count: N)
        var sol = Array(repeating: -1, count: N) // sol[r] = c
        func isAdjDiag(_ r1:Int,_ c1:Int,_ r2:Int,_ c2:Int) -> Bool { abs(r1-r2)==1 && abs(c1-c2)==1 }
        func dfs(_ r:Int) -> Bool {
            if r==N { return true }
            for c in 0..<N where !colUsed[c] {
                let rg = regions[r][c]; if regUsed[rg] { continue }
                var ok=true
                for rr in 0..<r { if isAdjDiag(rr, sol[rr], r, c) { ok=false; break } }
                if !ok { continue }
                sol[r]=c; colUsed[c]=true; regUsed[rg]=true
                if dfs(r+1) { return true }
                sol[r]-=1; colUsed[c]=false; regUsed[rg]=false
            }
            return false
        }
        return dfs(0) ? (0..<N).map{ BoardIndex(r:$0,c:sol[$0]) } : nil
    }

    static func generateSolvablePuzzle(size N: Int, maxTries: Int = 200) -> Puzzle {
        for _ in 0..<maxTries {
            let regs = makeRegions(size: N)
            if let _ = solve(size: N, regions: regs) { return Puzzle(size: N, regionIds: regs, presetQueens: []) }
        }
        // Fallback: striped rows (always solvable)
        let regs = (0..<N).map { r in Array(repeating: r, count: N) }
        return Puzzle(size: N, regionIds: regs, presetQueens: [])
    }

    func loadNew(size N: Int) {
        let p = GameVM.generateSolvablePuzzle(size: N)
        self.puzzle = p
        self.board = BoardState.empty(size: p.size, preset: p.presetQueens)
        self.history.removeAll()
        rebuildAutoMarks()
    }
}

// MARK: - UI

struct QueensGameView: View {
    @StateObject private var vm = GameVM(puzzle: samplePuzzles[0])
    @State private var sizeSelection: Int = 6

    var body: some View {
        NavigationStack {
            VStack(spacing: 12) {
                boardGrid
                footerBar
            }
            .padding()
            .navigationTitle("Queens")
            .toolbar { ToolbarItem(placement: .topBarTrailing) { Button("Reset") { vm.reset() } } }
        }
    }

    private var boardGrid: some View {
        let N = vm.size
        return GeometryReader { geo in
            let side = min(geo.size.width, geo.size.height)
            let cell = (side - 8) / CGFloat(N)
            VStack(spacing: 2) {
                ForEach(0..<N, id: \.self) { r in
                    HStack(spacing: 2) {
                        ForEach(0..<N, id: \.self) { c in
                            cellView(r, c)
                                .frame(width: cell, height: cell)
                        }
                    }
                }
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
        }
        .aspectRatio(1, contentMode: .fit)
    }

    private func cellView(_ r: Int, _ c: Int) -> some View {
        let idx = BoardIndex(r: r, c: c)
        let region = vm.puzzle.regionIds[r][c]
        let isPreset = vm.board.presetQueens.contains(idx)
        return ZStack {
            RoundedRectangle(cornerRadius: 6)
                .fill(regionColor(region))
                .overlay(RoundedRectangle(cornerRadius: 6).stroke(.secondary.opacity(0.6), lineWidth: 1))
            switch vm.board.cells[r][c] {
            case .empty:
                EmptyView()
            case .queen:
                let bad = vm.isQueenViolating(r, c)
                Text("ðŸ‘‘").font(.system(size: 26)).foregroundStyle(bad ? .red : .primary)
            case .mark:
                Text("X").font(.headline).foregroundStyle(.secondary)
            }
        }
        .overlay(RoundedRectangle(cornerRadius: 6).stroke((vm.board.cells[r][c] == .queen && vm.isQueenViolating(r, c)) ? .red : .clear, lineWidth: 2))
        .onTapGesture { vm.cycle(r, c) }
        .onLongPressGesture(minimumDuration: 0.25) { vm.longPressMark(r, c) }
    }

    private var footerBar: some View {
        VStack(spacing: 8) {
            HStack {
                Button("Undo") { vm.undo() }
                    .buttonStyle(.bordered)
                    .disabled(vm.history.isEmpty)
                Spacer()
                if vm.checkViolations().isEmpty && vm.isSolved() {
                    Label("Solved!", systemImage: "checkmark.seal.fill").foregroundStyle(.green)
                }
            }
            HStack(spacing: 12) {
                Picker("Size", selection: $sizeSelection) {
                    ForEach([5,6,7,8], id: \.self) { s in
                        Text("\(s)x\(s)").tag(s)
                    }
                }
                .pickerStyle(.segmented)
                Button("New Puzzle") { vm.loadNew(size: sizeSelection) }
                    .buttonStyle(.borderedProminent)
            }
            Toggle("Auto X", isOn: $vm.autoXEnabled)
                .onChange(of: vm.autoXEnabled) { _ in vm.rebuildAutoMarks() }
            Text("Tap: empty -> X -> ðŸ‘‘ -> empty. Long-press toggles X. 1 per row/column/region; no diagonal touching.")
                .font(.footnote)
                .foregroundStyle(.secondary)
        }
    }

    private func regionColor(_ id: Int) -> Color {
        let palette: [Color] = [
            Color(red:0.96, green:0.94, blue:1.00),
            Color(red:0.93, green:0.98, blue:0.95),
            Color(red:1.00, green:0.96, blue:0.92),
            Color(red:0.94, green:0.97, blue:1.00),
            Color(red:1.00, green:0.94, blue:0.96),
            Color(red:0.97, green:1.00, blue:0.94),
            Color(red:0.98, green:0.98, blue:0.98)
        ]
        return palette[id % palette.count]
    }
}

#Preview { QueensGameView() }
